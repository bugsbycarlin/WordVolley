

First draft database structure

{
  "games": { // these are the games currently being played
    "ahgeb": { // a five character alpha string
      "player_1_present": true,
      "player_2_present": true, 
      "player1_name": "jimbo", // let's limit this to something like twelve character ascii
      "player2_name": "hamchan",
      "player1_character": "a", // must be a single character
      "player2_character": "a", // must be a single character
      "player1_score": 0, // non-negative integer
      "player2_score": 2,
      "origin": "fish", //origin and target must have matching length
      "target": "hogs",
      "volley": "fish-fist-gist-gust", // dash separated list of alphanumeric strings of same length
      "turn": "player1" // must be player1 or player2
    } 
  }
}


Database calls:

create(game_name)
game_name must be a five character alpha string. it is randomly generated by the game.
if collision, it will return a negative, so the system can try again.
otherwise, make the following record and return it:
"fhsks": {
  "player_1_present": true,
  "player_2_present": false, 
  "player1_name": "",
  "player2_name": "",
  "player1_character": "",
  "player2_character": "",
  "player1_score": 0,
  "player2_score": 0,
  "origin": "",
  "target": "",
  "volley": "",
  "turn": ""
}

check(game_name)
game_name must be a five character alpha string
if not found, it will return negative
if found, it will return the game. use this to determine if players exist.

join(game_name)
game_name must be a five character alpha string.
if not found, it will return negative.
otherwise this just sets player_2_present to true. note this means someone
could over-join a game, effectively stealing control from someone else.

set(game_name, values)
use to set any value for game_name
returns negative if no match is found

read(game_name)
read the values for a game
returns negative if no match is found



Hmm... it doesn't work that way! I need to check stuff first.



Gradual drafts of database rules:


{
  "rules": {
    ".read": true,
    ".write": false,
   "games": {
      "$game_name": {
        ".validate": "$game_name.matches(/^[a-z]{5}$/)",
        ".write": "!data.exists()",
      }
    }
  }
}

this prevents the games list from being totally overwritten, prevents existing games from being overwritten, and requires that new games are keyed with five alphabetical characters.



{
  "rules": {
    ".read": true,
    ".write": false,
   "games": {
      "$game_name": {
        ".validate": "$game_name.matches(/^[a-z]{5}$/) && newData.hasChildren(['player_1_present', 'player_2_present', 'player1_name', 'player2_name', 'player1_character', 'player2_character', 'player1_score', 'player2_score', 'origin', 'target', 'volley', 'turn'])",
        ".write": "!data.exists()",
      }
    }
  }
}


this one additionally requires that new games have all the correct children as specified in the structure above.


Edit with game rules:



{
  "games": { // these are the games currently being played
    "ahgeb": { // a five character alpha string
      "player_1_present": true,
      "player_2_present": true, 
      "player1_name": "jimbo", // let's limit this to something like twelve character ascii
      "player2_name": "hamchan",
      "player1_character": "a", // must be a single character
      "player2_character": "a", // must be a single character
      "player1_score": 0, // non-negative integer
      "player2_score": 2,
      "origin": "fish", //origin and target must have matching length
      "target": "hogs",
      "volley": "fish-fist-gist-gust", // dash separated list of alphanumeric strings of same length
      "turn": "player1" // must be player1 or player2
      "time_limit" // 5, 10, 20, 30, 60, 300, -1 for infinity
    } 
  }
}