

First draft database structure

{
  "games": { // these are the games currently being played
    "ahgeb": { // a five character alpha string
      "player_1_present": true,
      "player_2_present": true, 
      "player1_name": "jimbo", // let's limit this to something like twelve character ascii
      "player2_name": "hamchan",
      "player1_character": "a", // must be a single character
      "player2_character": "a", // must be a single character
      "player1_score": 0, // non-negative integer
      "player2_score": 2,
      "origin": "fish", //origin and target must have matching length
      "target": "hogs",
      "volley": "fish-fist-gist-gust", // dash separated list of alphanumeric strings of same length
      "turn": "player1" // must be player1 or player2
    } 
  }
}


Database calls:

create(game_name)
game_name must be a five character alpha string. it is randomly generated by the game.
if collision, it will return a negative, so the system can try again.
otherwise, make the following record and return it:
"fhsks": {
  "player_1_present": true,
  "player_2_present": false, 
  "player1_name": "",
  "player2_name": "",
  "player1_character": "",
  "player2_character": "",
  "player1_score": 0,
  "player2_score": 0,
  "origin": "",
  "target": "",
  "volley": "",
  "turn": ""
}

check(game_name)
game_name must be a five character alpha string
if not found, it will return negative
if found, it will return the game. use this to determine if players exist.

join(game_name)
game_name must be a five character alpha string.
if not found, it will return negative.
otherwise this just sets player_2_present to true. note this means someone
could over-join a game, effectively stealing control from someone else.

set(game_name, values)
use to set any value for game_name
returns negative if no match is found

read(game_name)
read the values for a game
returns negative if no match is found



Hmm... it doesn't work that way! I need to check stuff first.



Gradual drafts of database rules:


{
  "rules": {
    ".read": true,
    ".write": false,
   "games": {
      "$game_name": {
        ".validate": "$game_name.matches(/^[a-z]{5}$/)",
        ".write": "!data.exists()",
      }
    }
  }
}

this prevents the games list from being totally overwritten, prevents existing games from being overwritten, and requires that new games are keyed with five alphabetical characters.



{
  "rules": {
    ".read": true,
    ".write": false,
   "games": {
      "$game_name": {
        ".validate": "$game_name.matches(/^[a-z]{5}$/) && newData.hasChildren(['player_1_present', 'player_2_present', 'player1_name', 'player2_name', 'player1_character', 'player2_character', 'player1_score', 'player2_score', 'origin', 'target', 'volley', 'turn'])",
        ".write": "!data.exists()",
      }
    }
  }
}


this one additionally requires that new games have all the correct children as specified in the structure above.


Edit with game rules:



{
  "games": { // these are the games currently being played
    "ahgeb": { // a five character alpha string
      "player_1_present": true,
      "player_2_present": true, 
      "player1_name": "jimbo", // let's limit this to something like twelve character ascii
      "player2_name": "hamchan",
      "player1_character": "a", // must be a single character
      "player2_character": "a", // must be a single character
      "player1_score": 0, // non-negative integer
      "player2_score": 2,
      "origin": "fish", //origin and target must have matching length
      "target": "hogs",
      "volley": "fish-fist-gist-gust", // dash separated list of alphanumeric strings of same length
      "turn": "player1" // must be player1 or player2
      "time_limit" // 5, 10, 20, 30, 60, 300, -1 for infinity
    } 
  }
}





Edit permissions with time limit, capital letters, and some entry validations:



{
  "rules": {
    ".read": true,
    ".write": false,
   "games": {
      "$game_name": {
        ".validate": "$game_name.matches(/^[A-Z]{5}$/) && newData.hasChildren(['player_1_present', 'player_2_present', 'player_1_character', 'player_2_character', 'player_1_score', 'player_2_score', 'time_limit', 'origin', 'target', 'volley', 'turn'])",
        ".write": "!data.exists()",
        "volley": {
          ".write": true,
        },
        "player_1_present": {
          ".write": true,
          ".validate": "newData.val() == true || newData.val() == false",
        },
        "player_2_present": {
          ".write": true,
          ".validate": "newData.val() == true || newData.val() == false",
        },
        "player_1_character": {
          ".write": true,
          ".validate": "newData.val().matches(/^[A-Z]{1}$/)",
        },
        "player_2_character": {
          ".write": true,
          ".validate": "newData.val().matches(/^[A-Z]{1}$/)",
        },
        "player_1_score": {
          ".write": true,
          ".validate": "newData.isNumber() && newData.val() % 1 === 0.0 && newData.val() >= 0",
        },
        "player_2_score": {
          ".write": true,
          ".validate": "newData.isNumber() && newData.val() % 1 === 0.0 && newData.val() >= 0",
        },
      }
    }
  }
}


now with names back in:




{
  "rules": {
    ".read": true,
    ".write": false,
   "games": {
      "$game_name": {
        ".validate": "$game_name.matches(/^[A-Z]{5}$/) && newData.hasChildren(['player_1_present', 'player_2_present', 'player_1_ready', 'player_2_ready', 'player_1_character', 'player_2_character', 'player_1_name', 'player_2_name', 'player_1_score', 'player_2_score', 'time_limit', 'origin', 'target', 'volley', 'turn'])",
        ".write": "!data.exists()",
        "player_1_present": {
          ".write": true,
          ".validate": "newData.val() == true || newData.val() == false",
        },
        "player_2_present": {
          ".write": true,
          ".validate": "newData.val() == true || newData.val() == false",
        },
        "player_1_ready": {
          ".write": true,
          ".validate": "newData.val() == true || newData.val() == false",
        },
        "player_2_ready": {
          ".write": true,
          ".validate": "newData.val() == true || newData.val() == false",
        },
        "player_1_character": {
          ".write": true,
          ".validate": "newData.val().matches(/^[A-Z]{1}$/)",
        },
        "player_2_character": {
          ".write": true,
          ".validate": "newData.val().matches(/^[A-Z]{1}$/)",
        },
        "player_1_name": {
          ".write": true,
          ".validate": "newData.val().matches(/^[A-Z]{1,8}$/)",
        },
        "player_2_name": {
          ".write": true,
          ".validate": "newData.val().matches(/^[A-Z]{1,8}$/)",
        },
        "player_1_score": {
          ".write": true,
          ".validate": "newData.isNumber() && newData.val() % 1 === 0.0 && newData.val() >= 0",
        },
        "player_2_score": {
          ".write": true,
          ".validate": "newData.isNumber() && newData.val() % 1 === 0.0 && newData.val() >= 0",
        },
        "time_limit": {
          ".write": true,
        },
        "origin": {
          ".write": true,
        },
        "target": {
          ".write": true,
        },
        "volley": {
          ".write": true,
        },
        "turn": {
          ".write": true,
        },
      }
    }
  }
}




updated with a live word tracker and some more safety validation:




{
  "rules": {
    ".read": true,
    ".write": false,
   "games": {
      "$game_name": {
        ".validate": "$game_name.matches(/^[A-Z]{5}$/) && newData.hasChildren(['player_1_present', 'player_2_present', 'player_1_ready', 'player_2_ready', 'player_1_character', 'player_2_character', 'player_1_name', 'player_2_name', 'player_1_score', 'player_2_score', 'time_limit', 'word_size', 'origin', 'target', 'volley', 'turn', 'live_word', 'volley_state'])",
        ".write": "!data.exists()",
        "player_1_present": {
          ".write": true,
          ".validate": "newData.val() == true || newData.val() == false",
        },
        "player_2_present": {
          ".write": true,
          ".validate": "newData.val() == true || newData.val() == false",
        },
        "player_1_ready": {
          ".write": true,
          ".validate": "newData.val() == true || newData.val() == false",
        },
        "player_2_ready": {
          ".write": true,
          ".validate": "newData.val() == true || newData.val() == false",
        },
        "player_1_character": {
          ".write": true,
          ".validate": "newData.val().matches(/^[A-Z]{1}$/)",
        },
        "player_2_character": {
          ".write": true,
          ".validate": "newData.val().matches(/^[A-Z]{1}$/)",
        },
        "player_1_name": {
          ".write": true,
          ".validate": "newData.val().matches(/^[A-Z]{1,8}$/)",
        },
        "player_2_name": {
          ".write": true,
          ".validate": "newData.val().matches(/^[A-Z]{1,8}$/)",
        },
        "player_1_score": {
          ".write": true,
          ".validate": "newData.isNumber() && newData.val() % 1 === 0.0 && newData.val() >= 0",
        },
        "player_2_score": {
          ".write": true,
          ".validate": "newData.isNumber() && newData.val() % 1 === 0.0 && newData.val() >= 0",
        },
        "time_limit": {
          ".write": true,
          ".validate": "newData.isNumber() && newData.val() % 1 === 0.0 && newData.val() >= 0",
        },
        "word_size": {
          ".write": true,
          ".validate": "newData.isNumber() && newData.val() % 1 === 0.0 && newData.val() >= 0",
        },
        "origin": {
          ".write": true,
          ".validate": "newData.val().matches(/^[A-Z]{0,8}$/)",
        },
        "target": {
          ".write": true,
          ".validate": "newData.val().matches(/^[A-Z]{0,8}$/)",
        },
        "volley": {
          ".write": true,
          ".validate": "newData.val().matches(/^[A-Z-]*$/)",
        },
        "turn": {
          ".write": true,
          ".validate": "newData.isNumber() && newData.val() % 1 === 0.0 && newData.val() >= 0",
        },
        "live_word": {
          ".write": true,
          ".validate": "newData.val().matches(/^[A-Z]{0,8}$/)",
        },
        "volley_state": {
          ".write": true,
          ".validate": "newData.val().matches(/^[a-z_]{0,40}$/)",
        },
      }
    }
  }
}


going to add a timestamp, then index on timestamp and player_1_ready for automatch




"$game_name": {
  ".indexOn": ["timestamp", "player_1_ready"]
}


{
  "rules": {
    ".read": true,
    ".write": false,
   "games": {
      "$game_name": {
        ".validate": "$game_name.matches(/^[A-Z]{5}$/) && newData.hasChildren(['player_1_present', 'player_2_present', 'player_1_ready', 'player_2_ready', 'player_1_character', 'player_2_character', 'player_1_name', 'player_2_name', 'player_1_score', 'player_2_score', 'time_limit', 'word_size', 'origin', 'target', 'volley', 'turn', 'live_word', 'volley_state', 'timestamp'])",
        ".write": "!data.exists()",
        ".indexOn": ["timestamp", "player_1_ready", "player_2_ready"],
        "player_1_present": {
          ".write": true,
          ".validate": "newData.val() == true || newData.val() == false",
        },
        "player_2_present": {
          ".write": true,
          ".validate": "newData.val() == true || newData.val() == false",
        },
        "player_1_ready": {
          ".write": true,
          ".validate": "newData.val() == true || newData.val() == false",
        },
        "player_2_ready": {
          ".write": true,
          ".validate": "newData.val() == true || newData.val() == false",
        },
        "player_1_character": {
          ".write": true,
          ".validate": "newData.val().matches(/^[A-Z]{1}$/)",
        },
        "player_2_character": {
          ".write": true,
          ".validate": "newData.val().matches(/^[A-Z]{1}$/)",
        },
        "player_1_name": {
          ".write": true,
          ".validate": "newData.val().matches(/^[A-Z]{1,8}$/)",
        },
        "player_2_name": {
          ".write": true,
          ".validate": "newData.val().matches(/^[A-Z]{1,8}$/)",
        },
        "player_1_score": {
          ".write": true,
          ".validate": "newData.isNumber() && newData.val() % 1 === 0.0 && newData.val() >= 0",
        },
        "player_2_score": {
          ".write": true,
          ".validate": "newData.isNumber() && newData.val() % 1 === 0.0 && newData.val() >= 0",
        },
        "time_limit": {
          ".write": true,
          ".validate": "newData.isNumber() && newData.val() % 1 === 0.0 && newData.val() >= 0",
        },
        "word_size": {
          ".write": true,
          ".validate": "newData.isNumber() && newData.val() % 1 === 0.0 && newData.val() >= 0",
        },
        "origin": {
          ".write": true,
          ".validate": "newData.val().matches(/^[A-Z]{0,8}$/)",
        },
        "target": {
          ".write": true,
          ".validate": "newData.val().matches(/^[A-Z]{0,8}$/)",
        },
        "volley": {
          ".write": true,
          ".validate": "newData.val().matches(/^[A-Z-]*$/)",
        },
        "turn": {
          ".write": true,
          ".validate": "newData.isNumber() && newData.val() % 1 === 0.0 && newData.val() >= 0",
        },
        "live_word": {
          ".write": true,
          ".validate": "newData.val().matches(/^[A-Z]{0,8}$/)",
        },
        "volley_state": {
          ".write": true,
          ".validate": "newData.val().matches(/^[a-z_]{0,40}$/)",
        },
        "timestamp": {
          ".write": true,
          ".validate": "newData.val() == now",
        }
      }
    }
  }
}


More changes:

I want to distinguish between games where the player has left and games where the player has not left. Combining present and ready into state to allow that. I also want to roll character into name, because I can get the character from the name. I also want game type. Here's a new rule set to take that into account.




{
  "rules": {
    ".read": true,
    ".write": false,
   "games": {
      ".indexOn": ["timestamp", "player_1_state", "player_2_state", "game_type"],
      "$game_name": {
        ".validate": "$game_name.matches(/^[A-Z]{5}$/) && newData.hasChildren([
          'game_type', // quick_open, quick_closed, code_comp, code_coop
          'player_1_state',   // empty, joined, ready, quit
          'player_2_state', // empty, joined, ready, quit
          'player_1_name',
          'player_2_name',
          'player_1_score',
          'player_2_score',
          'time_limit',
          'word_size',
          'origin',
          'target',
          'volley',
          'turn',
          'live_word',
          'volley_state',
          'timestamp'
        ])",
        ".write": "!data.exists()",
        "game_type": {
          ".write": true,
          ".validate": "newData.val() == 'quick_open' || newData.val() == 'quick_closed' || newData.val() == 'code_comp' || newData.val() == 'code_coop'",
        },
        "player_1_state": {
          ".write": true,
          ".validate": "newData.val() == 'empty' || newData.val() == 'joined' || newData.val() == 'ready' || newData.val() == 'quit' || newData.val() == 'win' || newData.val() == 'ended'",
        },
        "player_2_state": {
          ".write": true,
          ".validate": "newData.val() == 'empty' || newData.val() == 'joined' || newData.val() == 'ready' || newData.val() == 'quit' || newData.val() == 'win' || newData.val() == 'ended'",
        },
        "player_1_name": {
          ".write": true,
          ".validate": "newData.val().matches(/^[A-Z]{1,8}$/)",
        },
        "player_2_name": {
          ".write": true,
          ".validate": "newData.val().matches(/^[A-Z]{1,8}$/)",
        },
        "player_1_score": {
          ".write": true,
          ".validate": "newData.isNumber() && newData.val() % 1 === 0.0 && newData.val() >= 0",
        },
        "player_2_score": {
          ".write": true,
          ".validate": "newData.isNumber() && newData.val() % 1 === 0.0 && newData.val() >= 0",
        },
        "time_limit": {
          ".write": true,
          ".validate": "newData.isNumber() && newData.val() % 1 === 0.0 && newData.val() >= 0",
        },
        "word_size": {
          ".write": true,
          ".validate": "newData.isNumber() && newData.val() % 1 === 0.0 && newData.val() >= 0",
        },
        "origin": {
          ".write": true,
          ".validate": "newData.val().matches(/^[A-Z]{0,8}$/)",
        },
        "target": {
          ".write": true,
          ".validate": "newData.val().matches(/^[A-Z]{0,8}$/)",
        },
        "volley": {
          ".write": true,
          ".validate": "newData.val().matches(/^[A-Z-]*$/)",
        },
        "turn": {
          ".write": true,
          ".validate": "newData.isNumber() && newData.val() % 1 === 0.0 && newData.val() >= 0",
        },
        "live_word": {
          ".write": true,
          ".validate": "newData.val().matches(/^[A-Z]{0,8}$/)",
        },
        "volley_state": {
          ".write": true,
          ".validate": "newData.val().matches(/^[a-z_]{0,40}$/)",
        },
        "timestamp": {
          ".write": true,
          ".validate": "newData.val() == now",
        }
      }
    }
  }
}